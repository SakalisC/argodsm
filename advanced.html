<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Advanced - ArgoDSM</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="style.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav>
<ul>
	<li><a href="/argodsm/">Home</a></li>
	<li><a href="/argodsm/documentation.html">Documentation</a></li>
	<li><a href="/argodsm/tutorial.html">Tutorial</a></li>
	<li><a href="/argodsm/download.html">Download</a></li>
	<li><a href="/argodsm/about.html">About</a></li>
</ul>
</nav>
<h1 id="advanced-topics">Advanced Topics</h1>
<p>This document contains some information about the more advanced aspects of ArgoDSM.</p>
<h2 id="allocation-parameters">Allocation Parameters</h2>
<p>All the allocation functions available in ArgoDSM are function templates that accept three sets of template parameters.</p>
<ol type="1">
<li>The type to be allocated (required)</li>
<li>Allocation parameters (optional)</li>
<li>Constructor argument types (optional)</li>
</ol>
<p>The first set consists of exactly one parameter, which is the type to allocate and potentially initialize. The second set consists of values of type <code>argo::allocation</code>, which allow the user to alter the behavior of the allocation function. The third set consists of the types of the constructor arguments, and it's best left blank, as the compiler can deduce it automatically.</p>
<p>Other than the template parameters, the allocation functions also accept constructor arguments, when applicable. Specifically, the single object allocation functions accept constructor arguments, while the array allocation functions do not. Instead, they accept the size (in elements) of the array. This resembles the C++ <code>new</code> expressions, where it is not possible to initialize a whole array with a single value.</p>
<p>As mentioned earlier, the allocation functions can also initialize the allocated space, based on the type allocated. This is done for both the single and the array allocations, but not for all cases. Specifically, if the allocated type is of <a href="http://en.cppreference.com/w/cpp/concept/TrivialType"><code>TrivialType</code></a> then it will not be initialized, unless constructor arguments are provided. For example:</p>
<div class="sourceCode"><pre class="sourceCode Cpp"><code class="sourceCode cpp"><span class="dt">int</span> *a = argo::new_&lt;<span class="dt">int</span>&gt;(); <span class="co">// Not initialized</span>
<span class="dt">int</span> *b = argo::new_&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>); <span class="co">// Initialized</span></code></pre></div>
<p>In addition to the initialization of the allocated memory, the collective allocation functions can also act as a synchronization mechanism between the different threads. This is achieved through the <code>argo::barrier</code> function, and the synchronization is implied if initialization also takes place. In the case of the dynamic allocation functions, synchronization is never performed.</p>
<p>Which brings us to the allocation parameters mentioned above. It is possible for the user to alter the behavior of the allocation functions by passing the appropriate allocation parameters. At the time that this is being written, it is possible to explicitly enable or disable both the initialization and the synchronization that each function might perform, with the exception that the dynamic allocation functions ignore the synchronization arguments. For example:</p>
<div class="sourceCode"><pre class="sourceCode Cpp"><code class="sourceCode cpp"><span class="dt">int</span> *a = argo::new_&lt;<span class="dt">int</span>, argo::allocation::initialize&gt;(); <span class="co">// Initialized</span>
<span class="dt">int</span> *b = argo::new_&lt;<span class="dt">int</span>, argo::allocation::no_initialize&gt;(<span class="dv">0</span>); <span class="co">// Not initialized</span></code></pre></div>
<p>The deallocation functions work similarly to their allocation counterparts, only some of the allocation parameters are named differently, as instead of initialization, destruction is performed. So, instead of accepting <code>argo::[no_]initialize</code> they accept <code>argo::[no_]deinitialize</code>. Also, only one function argument is accepted, and that is the pointer to the memory that will be deallocated.</p>
</body>
</html>
